# ADR-0001: Core Architectural Boundaries

> **Status:** Accepted  
> **Date:** 2026-02-23  
> **Decision makers:** Jannis (admin), Gemini (architect)

---

## Context

Wanda is a cleanroom, local-first personal AI agent inspired by patterns from OpenClaw and Agent-Zero. The core challenge is building a system that is:

1. **Secure by default** — not "secure if configured correctly"
2. **Modular** — new channels, providers, and tools plug in without core rewrites
3. **Fully understood** — every line of code is first-party and audited
4. **Local-first** — no mandatory cloud services, no exposed ports

This ADR establishes the non-negotiable architectural boundaries.

---

## Decisions

### D1: Cleanroom Implementation — No Code Reuse

**Decision:** All code is written from scratch. OpenClaw and Agent-Zero are studied for patterns only.

**Rationale:**
- Upstream codebases are large and complex; forking creates hidden dependencies.
- Security auditing requires understanding every code path.
- License clarity: no ambiguous IP entanglements.
- "Development hell" avoidance: no fighting against upstream assumptions.

**Consequence:** Higher initial effort, but complete control and understanding.

---

### D2: Channel Adapter Pattern — Brain Never Knows the Channel

**Decision:** All messaging channels (Telegram, Discord, WhatsApp) implement a `ChannelAdapter` interface that normalizes messages into typed `InboundMessage` / `OutboundMessage` events.

```typescript
interface ChannelAdapter {
  readonly id: string;
  start(): Promise<void>;
  stop(): Promise<void>;
  sendMessage(msg: OutboundMessage): Promise<void>;
  onMessage(handler: (msg: InboundMessage) => void): void;
}
```

**Rationale:**
- Core logic is channel-agnostic; adding Discord or WhatsApp never touches the brain.
- Inspired by OpenClaw's Gateway pattern (channels decoupled from brain via typed protocol).
- Testing: brain can be tested against a mock adapter.

**Consequence:** Channel-specific features (reactions, threads, media) must be abstracted or deferred.

---

### D3: Secret Handle System — `secret://<id>`

**Decision:** The LLM never sees raw secret values. All secrets are referenced by opaque `secret://<id>` handles. The Secret Resolver decrypts values just-in-time at tool execution.

**Flow:**
```
LLM says: "Use secret://anthropic-key to authenticate"
     ↓
Tool Runner intercepts secret:// reference
     ↓
Secret Resolver decrypts from /data/secrets.db
     ↓
Actual API key injected into tool HTTP request
     ↓
Secret value NEVER enters logs, traces, or prompts
```

**Rationale:**
- Agent-Zero's approach (secrets by name in prompts) leaks values into LLM context.
- OpenClaw stores credentials on disk in config JSON — readable by any process.
- Wanda's approach: secrets encrypted at rest (SQLCipher or libsodium/age), resolved JIT.

**Consequence:** Tools must declare which secrets they need in their schema. Adds complexity to tool registration.

---

### D4: Pairing-First Identity — Zero Response to Unknown Users

**Decision:** Unknown Telegram users receive **no response whatsoever**. The admin receives a pairing request with user_id, username, timestamp, and OTP.

**Rationale:**
- OpenClaw's pairing model is proven: code expires after 1 hour, 3 pending max.
- Any response to unknown users (even "I don't know you") reveals the bot is active.
- Pairing state stored in SQLite: status, created_at, last_seen, revoked_at.

**Consequence:** Bot appears "dead" to unauthorized users. This is intentional.

---

### D5: Docker Sandbox by Default — No Trust in Tool Execution

**Decision:** All tool execution runs inside Docker containers with hardened defaults:
- Non-root (`USER 1000`)
- `--cap-drop ALL`
- `--security-opt no-new-privileges`
- Read-only root filesystem
- Only `/data` writable (scoped to workspace)
- Network: default DENY outbound (allowlist per tool)

**Rationale:**
- OpenClaw's sandbox model proves this is practical (agent/session/shared scopes).
- Agent-Zero runs entirely in Docker — validates the containerized approach.
- Prevents tool overreach even if prompt injection succeeds.

**Consequence:** Tool execution has I/O overhead from Docker. Acceptable for security.

---

### D6: Lifecycle Hooks — Explicit, Typed, Async

**Decision:** The agent loop exposes typed lifecycle hooks:

```typescript
type Hook = {
  on_message_received:  (ctx: MessageContext) => Promise<void>;
  before_llm:           (ctx: LLMContext) => Promise<void>;
  after_llm:            (ctx: LLMResponse) => Promise<void>;
  before_tool_exec:     (ctx: ToolExecContext) => Promise<ToolExecContext | 'deny'>;
  after_tool_exec:      (ctx: ToolResult) => Promise<void>;
  on_error:             (ctx: ErrorContext) => Promise<void>;
};
```

**Rationale:**
- OpenClaw has 15+ hook points — too many for v1. We start with 6 essential ones.
- Agent-Zero uses file-ordered extensions — fragile and hard to reason about.
- Typed hooks are testable, composable, and self-documenting.

**Consequence:** Adding new hooks later is a breaking interface change. Start minimal.

---

### D7: Tool Registry with Zod Schemas

**Decision:** Every tool is registered with a zod schema that validates parameters before execution.

```typescript
const getTimeSchema = z.object({
  timezone: z.string().default('UTC'),
});

registry.register({
  name: 'get_current_time',
  description: 'Returns the current date and time',
  schema: getTimeSchema,
  dangerous: false,
  execute: async (params, ctx) => { /* ... */ },
});
```

**Rationale:**
- Prevents malformed tool calls from reaching execution.
- Schema serves as documentation for the LLM (converted to JSON Schema in system prompt).
- Dangerous flag triggers the OTP approval flow.
- OpenClaw uses TypeBox; we use zod because it's the TS ecosystem standard.

**Consequence:** Every tool must have a schema; no "dynamic" tools without registration.

---

### D8: MCP-Only Integrations — No Untrusted Code Execution

**Decision:** All external integrations run as **allowlisted MCP servers**. No arbitrary script execution, no community skill marketplace, no untrusted plugins.

**Rationale:**
- OpenClaw's community skills have had reported malicious cases.
- Agent-Zero's extensions run in-process — no isolation boundary.
- MCP provides a standardized protocol with process-level isolation.

**Consequence:** Integrations must implement the MCP protocol. Higher barrier to entry, stronger security.

---

### D9: Monorepo with pnpm Workspaces

**Decision:** Single monorepo with pnpm workspaces:

```
packages/
  core/       — agent loop, lifecycle hooks, config
  channels/   — adapter interface + implementations
  providers/  — LLM provider interface + implementations
  memory/     — SQLite + FTS5
  secrets/    — encrypted secret store
  tools/      — tool registry + built-in tools
  sandbox/    — Docker runner
  shared/     — types, logger (pino), utilities
apps/
  wanda-bot/  — entry point + Dockerfile
```

**Rationale:**
- Clear dependency graph; packages can be tested in isolation.
- pnpm is fast and enforces strict dependency resolution.
- Monorepo avoids version drift between packages.

**Consequence:** All packages share a single TypeScript config and CI pipeline.

---

### D10: No Exposed Ports — Outbound Only

**Decision:** Wanda has **zero inbound ports**:
- Telegram: long polling (outbound HTTPS only)
- No webhook endpoint
- Local IPC (`127.0.0.1`) disabled by default
- Docker container exposes no ports

**Rationale:**
- OpenClaw's exposed WebSocket server has been reported as a security concern.
- Eliminating inbound ports removes an entire attack surface.
- Long polling is simpler to deploy and works behind NAT/firewalls.

**Consequence:** Future channels that require webhooks (e.g., WhatsApp Business API) will need a separate ingress component with its own threat model.

---

## Consequences Summary

| Decision | Trade-off  |
|----------|-----------|
| D1 (cleanroom) | More initial work, but full control |
| D2 (channel adapters) | Channel features must be abstracted |
| D3 (secret handles) | Tool schemas more complex |
| D4 (pairing-first) | Bot invisible to strangers |
| D5 (Docker sandbox) | I/O overhead on tool exec |
| D6 (lifecycle hooks) | Minimal set; adding hooks is breaking |
| D7 (zod schemas) | No dynamic/unregistered tools |
| D8 (MCP-only) | Higher integration barrier |
| D9 (pnpm monorepo) | Single repo, shared CI |
| D10 (no ports) | Webhook channels deferred |

---

## References

- [UPSTREAM_PATTERNS.md](../01_research/UPSTREAM_PATTERNS.md)
- [THREAT_MODEL.md](../02_architecture/THREAT_MODEL.md)
- OpenClaw docs: https://docs.openclaw.ai
- Agent-Zero docs: https://www.agent-zero.ai/p/docs/
